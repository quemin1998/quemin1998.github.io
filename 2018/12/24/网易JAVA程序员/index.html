
<!DOCTYPE html>
<html lang="zh-Hans" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>网易JAVA程序员面试 - Wells Min</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="WellsMin,阙敏,个人博客,"> 
    <meta name="description" content="注：菜鸟日记，记录学习所得的知识点及任务进度记录
分享学习经验，记录小结
本文参考CSDN记录问题–传送门

面试GG要点
知其然不知其所以然”。做了多年技术，开发了很多业务应用，但似乎并未思考过种,"> 
    <meta name="author" content="Wells Min"> 
    <link rel="alternative" href="atom.xml" title="Wells Min" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>

<body class="loading">
    <span id="config-title" style="display:none">Wells Min</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" data-url="http://yoursite.com"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">网易JAVA程序员面试</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">网易JAVA程序员面试</h1>
        <div class="stuff">
            <span>十二月 24, 2018</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/FreeCodeCamp/">FreeCodeCamp</a></li></ul>


        </div>
        <div class="content markdown">
            <p><code>注：菜鸟日记，记录学习所得的知识点及任务进度记录</code></p>
<p><code>分享学习经验，记录小结</code></p>
<p><code>本文参考CSDN记录问题</code>–<a href="https://blog.csdn.net/pangziaichi/article/details/86499480" target="_blank" rel="noopener">传送门</a></p>
<hr>
<h2 id="面试GG要点"><a href="#面试GG要点" class="headerlink" title="面试GG要点"></a>面试GG要点</h2><ol>
<li><p><code>知其然不知其所以然”。做了多年技术，开发了很多业务应用，但似乎并未思考过种种技术选择背后的逻辑。所以，他无法向面试官展现出自己未来技术能力的成长潜力。面试官也不会放心把具有一定深度的任务交给他。</code> </p>
</li>
<li><p><code>知识碎片化，不成系统。在面试中，面试者似乎无法完整、清晰地描述自己所开发的系统，或者使用的相关技术。所以，会让面试官怀疑他是否具备高效解决复杂问题、设计复杂系统的能力。</code></p>
</li>
</ol>
<hr>
<h2 id="网易JAVA程序员一面"><a href="#网易JAVA程序员一面" class="headerlink" title="网易JAVA程序员一面"></a>网易JAVA程序员一面</h2><ol>
<li><p>volatile有什么用？—<a href="https://blog.csdn.net/hxpjava1/article/details/55188908" target="_blank" rel="noopener">传送门</a></p>
<ul>
<li><p>volatile关键字，内容涵盖volatile的保证内存可见性、禁止指令重排等</p>
<p>  <code>保证内存可见性</code></p>
<ul>
<li><p>可见性是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，另一个线程马上就能看到。</p>
</li>
<li><p>当对非volatile变量进行读写的时候，每个线程先从主内存拷贝变量到CPU缓存中，如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache中。 </p>
</li>
<li><p>volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，保证了每次读写变量都从主内存中读，跳过CPU cache这一步。当一个线程修改了这个变量的值，新值对于其他线程是立即得知的。 </p>
<p><code>禁止指令重排</code></p>
</li>
<li><p>指令重排序是JVM为了优化指令、提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。指令重排序包括编译器重排序和运行时重排序。 </p>
</li>
<li><p>在JDK1.5之后，可以使用volatile变量禁止指令重排序。针对volatile修饰的变量，在读写操作指令前后会插入内存屏障，指令重排序时不能把后面的指令重排序到内存屏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//示例说明：</span><br><span class="line">double r = 2.1; //(1) </span><br><span class="line">double pi = 3.14;//(2) </span><br><span class="line">double area = pi*r*r;//(3)</span><br></pre></td></tr></table></figure>
<p>代码语句的定义顺序为1-&gt;2-&gt;3，但是计算顺序1-&gt;2-&gt;3与2-&gt;1-&gt;3对结果并无影响，所以编译时和运行时可以根据需要对1、2语句进行重排序。</p>
<p>如果一个操作不是原子的，就会给JVM留下重排的机会。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">线程A中</span><br><span class="line">&#123;</span><br><span class="line">    context = loadContext();</span><br><span class="line">    inited = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程B中</span><br><span class="line">&#123;</span><br><span class="line">    if (inited) </span><br><span class="line">        fun(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果线程A中的指令发生了重排序，那么B中很可能就会拿到一个尚未初始化或尚未初始化完成的context,从而引发程序错误。</p>
</li>
<li><p>volatile关键字提供内存屏障的方式来防止指令被重排，编译器在生成字节码文件时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
</li>
<li><p>JVM内存屏障插入策略：</p>
<p>  每个volatile写操作的前面插入一个StoreStore屏障；</p>
<p>  在每个volatile写操作的后面插入一个StoreLoad屏障；</p>
<p>  在每个volatile读操作的后面插入一个LoadLoad屏障；</p>
<p>  在每个volatile读操作的后面插入一个LoadStore屏障。</p>
<p>基于双重检验的单例模式(懒汉型)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton3 &#123;</span><br><span class="line">    private static Singleton3 instance = null;</span><br><span class="line"></span><br><span class="line">    private Singleton3() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton3 getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized(Singleton3.class) &#123;</span><br><span class="line">                if (instance == null)</span><br><span class="line">                    instance = new Singleton3();// 非原子操作</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>instance= new Singleton()并不是一个原子操作，其实际上可以抽象为下面几条JVM指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();    //1：分配对象的内存空间 </span><br><span class="line">ctorInstance(memory);  //2：初始化对象 </span><br><span class="line">instance =memory;     //3：设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure>
<p>上面操作2依赖于操作1，但是操作3并不依赖于操作2。所以JVM是可以针对它们进行指令的优化重排序的，经过重排序后如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();    </span><br><span class="line">//1：分配对象的内存空间 </span><br><span class="line">instance =memory;</span><br><span class="line">//3：instance指向刚分配的内存地址，此时对象还未初始化</span><br><span class="line">ctorInstance(memory); </span><br><span class="line">//2：初始化对象</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>指令重排之后，instance指向分配好的内存放在了前面，而这段内存的初始化被排在了后面。在线程A执行这段赋值语句，在初始化分配对象之前就已经将其赋值给instance引用，恰好另一个线程进入方法判断instance引用不为null，然后就将其返回使用，导致出错。

- 用volatile关键字修饰instance变量，使得instance在读、写操作前后都会插入内存屏障，避免重排序。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton3 &#123;</span><br><span class="line">    private static volatile Singleton3 instance = null;</span><br><span class="line"></span><br><span class="line">    private Singleton3() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton3 getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized(Singleton3.class) &#123;</span><br><span class="line">                if (instance == null)</span><br><span class="line">                    instance = new Singleton3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

- volatile是轻量级同步机制。在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，是一种比synchronized关键字更轻量级的同步机制。 

- volatile`**`无法同时保证内存可见性和原子性。加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性`**`。

- volatile不能修饰写入操作依赖当前值的变量。声明为volatile的简单变量如果当前值与该变量以前的值相关，那么volatile关键字不起作用，也就是说如下的表达式都不是原子操作：“count++”、“count = count+1”。

- 当要访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile；

- volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。
</code></pre><ol start="2">
<li><p>Minor GC和Full GC的触发时机—<a href="https://blog.csdn.net/shi2huang/article/details/80067608" target="_blank" rel="noopener">传送门</a></p>
<p> Minor GC</p>
<ul>
<li><p>1.eden区满时，触发MinorGC。即申请一个对象时，发现eden区不够用，则触发一次MinorGC。</p>
</li>
<li><p>2.Full GC之前调用，仅适用于Parallel Scavenge（-XX:+UseParallelGC），虚拟机运行在Server模式下的默认收集器组合。</p>
</li>
<li><p>注：判断一个对象是否存活，除了GC Roots引用之外，还有一个条件就是对象是否重写了finalize方法，如果对象重写了该方法，则会交给FQueue队列去执行，如果执行该方法后被重新关联，则在下次回收时不会被回收，否则下次回收，该方法只执行一次。</p>
<p>Full GC</p>
</li>
<li><p>1.老生代空间不够分配新的内存，触发Full GC</p>
</li>
<li><p>2.System.gc()，见Minor GC触发条件的第2点。</p>
</li>
<li><p>3.通过Minor GC后进入老年代的平均大小大于老年代的可用内存。</p>
</li>
<li><p>4.Minor GC时，eden space和from space区大小大于to space且大于老年代内存，触发Full GC。</p>
</li>
<li><p>5.Metaspace空间不足</p>
</li>
</ul>
</li>
<li><p>反射用到了哪些接口，哪些类？—<a href="https://blog.csdn.net/vqqYuAn/article/details/45667471" target="_blank" rel="noopener">传送门</a></p>
<ul>
<li>String getName() : 获取类的完全限定名称；</li>
<li>String getSimpleName() : 获取类名，不带包名；</li>
<li>String getCanonicalName() : 获取类的完全限定名称；</li>
<li>Class[] getClasses() : 类内部定义的或者基类内部定义的具有public访问权限的内部类列表；</li>
<li>Class[] getDeclaredClasses() : 获取类内声明的内部类，不一定是public，不包括基类内部类；</li>
<li>Class getDeclaringClass() : 如果当前类为内部类，获取声明内部类的外部类，如果当前类不是内部类，或者当前类是一个数组类或者基本数据类型，返回null；</li>
<li>Class getEnclosingClass() : 如果当前类为内部类，获取声明内部类的外部类，如果当前类不是内部类，返回null；</li>
<li>Class[] getInterfaces() : 获取类实现的接口列表；</li>
<li>Type[] getGenericInterfaces() : 获取当前类直接实现的接口列表，不包括基类实现的接口，也不包括当前类实现接口的上层接口，如果当前类为基本数据类型，或者void类型，返回空列表；</li>
<li>Type getGenericSuperClass() : 获取类继承的基类；</li>
<li>Class getSuperClass() : 获取类继承的基类；</li>
<li><p>ClassLoader getClassLoader() : 获取类对应的类加载器；</p>
<h3 id="第二类，类型转换的接口"><a href="#第二类，类型转换的接口" class="headerlink" title="第二类，类型转换的接口"></a>第二类，类型转换的接口</h3></li>
<li><code>&lt;U&gt; Class&lt;? extends U&gt; asSubClass(Class&lt;U&gt; clazz)</code>:  Class对象类型转换，把当前Class对象转换为参数Class对象所表示类型的某个子类型Class对象，如果转换失败，抛出ClassCastException。</li>
<li><p>T cast(Object obj) : 普通对象类型转换，把参数对象转换成当前类对象所表示的类型的对象</p>
<h3 id="第三类，构造方法相关接口，Constructor是一个重要的泛型类"><a href="#第三类，构造方法相关接口，Constructor是一个重要的泛型类" class="headerlink" title="第三类，构造方法相关接口，Constructor是一个重要的泛型类"></a>第三类，构造方法相关接口，Constructor是一个重要的泛型类</h3></li>
<li>Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes) : 获取带有给定参数类型列表的构造函数，如果没有，抛出NoSuchMethodException；</t></li>
<li>Constructor<t> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) :</t></li>
<li>Constructor[] getConstructors() : </li>
<li>Constructor[] getDeclaredConstructors() : </li>
<li>Constructor&lt;?&gt; getEnclosingConstructor()<h3 id="第四类，方法相关的接口，Method是一个重要的反射类，后面会单独分析。"><a href="#第四类，方法相关的接口，Method是一个重要的反射类，后面会单独分析。" class="headerlink" title="第四类，方法相关的接口，Method是一个重要的反射类，后面会单独分析。"></a>第四类，方法相关的接口，Method是一个重要的反射类，后面会单独分析。</h3></li>
<li>Method getMethod(String name, Class&lt;?&gt;… parameterTypes) : 从当前类所在的继承结构中查找方法；</li>
<li>Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) :从当前类的定义中查找方法，不包括基类中定义的方法；</li>
<li>Method[] getMethods() : 从当前类所在的继承结构中获取所有方法列表；</li>
<li>Method[] getDeclaredMethods() : 从当前类的定义中获取方法列表，不包括基类中定义的方法；</li>
<li>Method getEnclosingMethod() <h3 id="第五类，成员相关的接口，Field是一个重要的反射类，后面会单独分析。"><a href="#第五类，成员相关的接口，Field是一个重要的反射类，后面会单独分析。" class="headerlink" title="第五类，成员相关的接口，Field是一个重要的反射类，后面会单独分析。"></a>第五类，成员相关的接口，Field是一个重要的反射类，后面会单独分析。</h3></li>
<li>Field getField(String name)</li>
<li>Field getDeclaredField(String name) : 这里Declared的意思，已经明了了吧。</li>
<li>Field[] getFields()</li>
<li>Field[] getDeclaredField()<h3 id="第六类，注释相关的接口"><a href="#第六类，注释相关的接口" class="headerlink" title="第六类，注释相关的接口"></a>第六类，注释相关的接口</h3></li>
<li><code>&lt;A extends Annotation&gt; getAnnotation(Class&lt;A&gt; annotationClass)</code></li>
<li>Annotation[] getAnnotations()</li>
<li>Annotation[] getDeclaredAnnotations()<h3 id="其他接口"><a href="#其他接口" class="headerlink" title="其他接口"></a>其他接口</h3></li>
<li>T[] getEnumConstants()</li>
<li>Package getPackage()</li>
<li>TypeVariable&lt;Class<t>&gt; getTypeParameters()</t></li>
<li>boolean isAnonymousClass() : 是否为匿名类；</li>
<li>boolean isAnnotation() : 是否为注释类；</li>
<li>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; clazz) : 是否有某类注释；</li>
<li>boolean isInstance(Object obj) ： 判断某对象是否为当前类型</li>
<li>boolean isEnum()</li>
<li>boolean isArray()</li>
<li>boolean isInterface()  </li>
<li>boolean isLocalClass()</li>
<li>boolean isPrimitive() : 是否为基本数据类型</li>
</ul>
</li>
<li><p>反射机制中可以获取private成员的值吗？—<a href="https://blog.csdn.net/codefunjava/article/details/39718843" target="_blank" rel="noopener">传送门</a></p>
<ul>
<li>可以</li>
<li>1.在cmd中编译时使用java -private xxx</li>
<li><p>2.在编写时:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">field1 = e.getClass().getDeclaredField(&quot;field1&quot;);</span><br></pre></td></tr></table></figure>
<p>  <code>getDeclaredField(String fieldName)中</code>，参数fieldName为属性名</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method method3 = e.getClass().getDeclaredMethod(&quot;fun3&quot;,String.class);</span><br></pre></td></tr></table></figure>
<p> <code>getDeclaredMethod(String methodName,Class parameterType</code>)中</p>
<p>  第一个参数为方法名，第二个参数为方法参数类型，当然在此方法中第二个参数为可娈参数。</p>
</li>
</ul>
</li>
<li><p>Java中sleep方法和wait方法的区别—<a href="https://www.cnblogs.com/plmnko/archive/2010/10/15/1851854.html" target="_blank" rel="noopener">传送门</a></p>
<ul>
<li><p>1.这两个方法来自的类不同，sleep来自Thread类，wait来自Object类。</p>
<p>  sleep是Thread类的静态方法，谁调用谁区睡觉，即使在a线程里调用了b的sleep方法，实际上还是a去睡觉的，要让b线程睡觉要在b的代码中调用sleep</p>
</li>
<li><p>2.重点：<code>sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。</code></p>
</li>
<li><p>3.使用范围：wait，notify，notifyAll只能在同步控制方法或者同步控制块内使用，但是sleep可以在任何地方使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(x)&#123;</span><br><span class="line">    x.notify();</span><br><span class="line">    //或者wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.sleep必须捕获异常，wait，notify，notifyAll不需要捕获异常</p>
</li>
</ul>
</li>
<li><p>Java中有哪些注解?在SpringMVC中，requestmapping是自定义注<br>解，问：如何实现自定义注解？</p>
<ul>
<li>@interface定义类，使用后可以实现自定义注解</li>
</ul>
</li>
</ol>
<hr>
<!-- ## 网易JAVA程序员二面
1. 线程池，threadpool有哪些重要的参数？
    - 滴滴

2. http协议头有哪些字段？
    - 滴滴

3. oracle如何实现分页（手写）
    - 1

4. SpringMVC在处理前端页面请求时，各模块是如何工作的？
    - 12

5. 数据库索引有什么作用?带来的问题是什么？
    - 123

6. 以前有没有用过Java枚举，如何使用的？
    - 232 -->
<hr>
<h2 id="项目介绍要点"><a href="#项目介绍要点" class="headerlink" title="项目介绍要点"></a>项目介绍要点</h2><ol>
<li><p>问及项目经验的时候，考察的并不是技术，而是你的项目概述能力</p>
</li>
<li><p>从一个项目的生命周期为基准线展开讲，这样介绍更有层次感。接下来要将你在项目中的比重，你负责主要点有哪些。</p>
</li>
<li><p>在项目概述之后，就要讨论每个项目过程中遇到的困难部分，因为大部分项目都会遇到这个问题，所以尽量真实地描述你是如何解决问题的，这也将体现你解决问题的思想。</p>
</li>
<li><p>有礼貌的询问面试官对于项目还有哪些疑问或者不清楚的地方。</p>
</li>
</ol>
<hr>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title='0' data-url='http://link.hhtjim.com/163/5146554.mp3'></li>
                    
                        <li title='1' data-url='http://link.hhtjim.com/qq/001faIUs4M2zna.mp3'></li>
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci='57cb4b95e6b05081411e'
        data-cs='f5d12e14d8ded22c26a2fbeb5adffee738b48ef1'
        data-r='http://www.quemin.top'
        data-o='quemin1998'
        data-a='quemin1998'
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>
